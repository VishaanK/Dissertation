/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;
import java.util.ArrayList;
import java.util.List;

import org.hyperledger.fabric.contract.Context;
import org.hyperledger.fabric.contract.ContractInterface;
import org.hyperledger.fabric.contract.annotation.Contact;
import org.hyperledger.fabric.contract.annotation.Contract;
import org.hyperledger.fabric.contract.annotation.Default;
import org.hyperledger.fabric.contract.annotation.Info;
import org.hyperledger.fabric.contract.annotation.License;
import org.hyperledger.fabric.contract.annotation.Transaction;
import org.hyperledger.fabric.shim.ChaincodeException;
import org.hyperledger.fabric.shim.ChaincodeStub;
import org.hyperledger.fabric.shim.ledger.KeyModification;
import org.hyperledger.fabric.shim.ledger.KeyValue;
import org.hyperledger.fabric.shim.ledger.QueryResultsIterator;

import com.owlike.genson.Genson;

@Contract(
        name = "document",
        info = @Info(
                title = "Document Logic",
                description = "Document Contract",
                version = "0.0.1",
                license = @License(
                        name = "Vish License",
                        url = "vish.com"),
                contact = @Contact(
                        email = "vish@vish.com",
                        name = "VishaanKhanna",
                        url = "https:vish.document.com")))
                        
@Default
public final class DocumentTransfer implements ContractInterface {

    private final Genson genson = new Genson();

    private enum DocumentTransferErrors {
        DOCUMENT_NOT_FOUND,
        DOCUMENT_ALREADY_EXISTS
    }



        /**
     * Creates some initial assets on the ledger.
     *
     * @param ctx the transaction context
     */
    @Transaction(intent = Transaction.TYPE.SUBMIT)
    public void InitLedger(final Context ctx) {
        System.out.println("Initialising ledger with no assets ");
    }

    /**
     * Create Document
     * @param ctx
     * @param documentID
     * @param documentName
     * @param creatorID
     * @param documentHash
     * @param documentType
     * @param signable
     * @return
     */
    @Transaction(intent=Transaction.TYPE.SUBMIT)
    public Document CreateDocument(final Context ctx,final String documentID, final String documentName , final String creatorID, final String documentHash,
                                final String documentType , final boolean signable,final double[] vector){

        ChaincodeStub stub = ctx.getStub();

        //check if a document of that id exists 
        String documentJSON = stub.getStringState(documentID);

            // Check if the document exists
            //if exists exit with error
            if (documentJSON != null && !documentJSON.isEmpty()) {
                throw new ChaincodeException("Document already exists for ID: " + documentID, DocumentTransferErrors.DOCUMENT_ALREADY_EXISTS.toString());
            }

        Document newDoc = new Document(documentID,creatorID, documentName, documentHash, documentType, signable,vector);

        // Use Genson to convert the Asset into string, sort it alphabetically and serialize it into a json string
        String sortedJson = genson.serialize(newDoc);
        stub.putStringState(documentID, sortedJson);

        return newDoc;

    }

    /**
     * Check that the document exists on ledger
     * @param ctx transaction context
     * @param documentID document id
     * @return true or false indicating assets existance 
     */
    @Transaction(intent = Transaction.TYPE.EVALUATE)
    public boolean CheckDocumentExists(final Context ctx, final String documentID){
        ChaincodeStub stub = ctx.getStub();
        String documentJSON = stub.getStringState(documentID);
        
        return (documentJSON != null && !documentJSON.isEmpty());

    }

    /**
     * Check that the hash of the document equals the hash on ledger to verify the authenticity of the document
     * @param ctx transaction context
     * @param documentID doc id
     * @param documentHash hash to check 
     * @return
     */
    @Transaction(intent= Transaction.TYPE.EVALUATE)
    public boolean CheckDocumentValidity(final Context ctx, final String documentID, final String documentHash){
        ChaincodeStub stub = ctx.getStub();
        
        String documentJSON = stub.getStringState(documentID);

            // Check if the is null
        if (documentJSON == null || documentJSON.isEmpty()) {
                throw new ChaincodeException("Document not found for ID: " + documentID , DocumentTransferErrors.DOCUMENT_NOT_FOUND.toString());
        }

        // Convert the JSON string to a JSONObject
        Document fetchedDoc = genson.deserialize(documentJSON,Document.class);
     

        // Access the documentHash field
        String fetchedHash = fetchedDoc.getDocumentHash();


        return documentHash.equals(fetchedHash);
    }

    /**
     * Read a document
     * @param ctx
     * @param documentName
     * @param userID
     * @return
     */
    @Transaction(intent = Transaction.TYPE.SUBMIT)
    public Document ReadDocument(final Context ctx, final String documentID,final String userID){
        ChaincodeStub stub = ctx.getStub();
        String documentJSON = stub.getStringState(documentID);

            // Check if the document exists
        if (documentJSON == null || documentJSON.isEmpty()) {
                throw new ChaincodeException("Document not found for ID: " + documentID , DocumentTransferErrors.DOCUMENT_NOT_FOUND.toString());
        }

        // Convert the JSON string to a JSONObject
        Document fetchedDoc = genson.deserialize(documentJSON,Document.class);
        
        //update last action and ID of reader
        fetchedDoc.setLastAction(DocumentAction.READ);
        fetchedDoc.setLastInteractedWithID(userID);

        String sortedJson = genson.serialize(fetchedDoc);

        stub.putStringState(documentID, sortedJson);

        return fetchedDoc;

    }

    /**
     * Update the hash of an existing item 
     * @param ctx
     * @param documentName
     * @param hash
     * @param userID
     * @return
     */
    @Transaction(intent = Transaction.TYPE.SUBMIT)
    public Document UpdateDocumentHash(Context ctx, final String documentID, final String hash,final String userID,final double[] newVector){
        ChaincodeStub stub = ctx.getStub();

        String documentJSON = stub.getStringState(documentID);

            // Check if the document exists
        if (documentJSON == null || documentJSON.isEmpty()) {
                throw new ChaincodeException("Document not found for ID: " + documentID , DocumentTransferErrors.DOCUMENT_NOT_FOUND.toString());
        }

        // Convert the JSON string to a JSONObject
        Document doc = genson.deserialize(documentJSON,Document.class);
        doc.setHash(hash);

        //update last action and ID of reader
        doc.setLastAction(DocumentAction.EDITED);
        doc.setLastInteractedWithID(userID);
        doc.setVector(newVector);
        
        String sortedJson = genson.serialize(doc);

        stub.putStringState(documentID, sortedJson);
        return doc;
    }


        /**
     * Update the hash of an existing item 
     * @param ctx
     * @param documentName
     * @param hash
     * @param userID
     * @return
     */
    @Transaction(intent = Transaction.TYPE.SUBMIT)
    public Document UpdateDocumentName(Context ctx, final String documentID, final String newdocumentName,final String userID){
        ChaincodeStub stub = ctx.getStub();

        String documentJSON = stub.getStringState(documentID);

            // Check if the document exists
        if (documentJSON == null || documentJSON.isEmpty()) {
                throw new ChaincodeException("Document not found for ID: " + documentID , DocumentTransferErrors.DOCUMENT_NOT_FOUND.toString());
        }

        // Convert the JSON string to a JSONObject
        Document doc = genson.deserialize(documentJSON,Document.class);
        doc.setName(newdocumentName);
         //update last action and ID of reader
        doc.setLastAction(DocumentAction.EDITED);
        doc.setLastInteractedWithID(userID);

         
        String sortedJson = genson.serialize(doc);

        stub.putStringState(documentID, sortedJson);
        return doc;
    }

        /**
     * Update the hash of an existing item 
     * @param ctx
     * @param documentName
     * @param hash
     * @param userID
     * @return
     */
    @Transaction(intent = Transaction.TYPE.SUBMIT)
    public Document UpdateDocumentSignable(Context ctx, final String documentID, final boolean signable,final String userID){
        ChaincodeStub stub = ctx.getStub();

        String documentJSON = stub.getStringState(documentID);

            // Check if the document exists
        if (documentJSON == null || documentJSON.isEmpty()) {
                throw new ChaincodeException("Document not found for ID: " + documentID , DocumentTransferErrors.DOCUMENT_NOT_FOUND.toString());
        }

        // Convert the JSON string to a JSONObject
        Document doc = genson.deserialize(documentJSON,Document.class);
        doc.setSignable(signable);
        //update last action and ID of reader
        doc.setLastAction(DocumentAction.EDITED);
        doc.setLastInteractedWithID(userID);

        String sortedJson = genson.serialize(doc);

        stub.putStringState(documentID, sortedJson);
        return doc;
    }

        /**
     * Deletes document on the ledger.
     *
     * @param ctx the transaction context
     * @param documentID the ID of the asset being deleted
     * @param userID
     */
    @Transaction(intent = Transaction.TYPE.SUBMIT)
    public boolean DeleteDocument(final Context ctx, final String documentID,final String userID) {
        ChaincodeStub stub = ctx.getStub();

        if (!CheckDocumentExists(ctx, documentID)) {
            String errorMessage = String.format("Document %s does not exist", documentID);
            System.out.println(errorMessage);
            throw new ChaincodeException(errorMessage, DocumentTransferErrors.DOCUMENT_NOT_FOUND.toString());
        }

        try {
            String documentJSON = stub.getStringState(documentID);

            Document doc = genson.deserialize(documentJSON,Document.class);
            //update last action and ID of reader
            doc.setLastAction(DocumentAction.DELETED);
            doc.setLastInteractedWithID(userID);
    
            //write the changes 
            String sortedJson = genson.serialize(doc);
            stub.putStringState(documentID, sortedJson);
    
            //delete the item
            stub.delState(documentID);
            return true;

        } catch (Exception e) {
            throw new ChaincodeException("Deletion failed due to an unexpected error", e.getMessage());
        }

    }

        /**
     * Retrieves all assets from the ledger.
     *
     * @param ctx the transaction context
     * @param userID
     * @return array of assets found on the ledger
     */
    @Transaction(intent = Transaction.TYPE.SUBMIT)
    public String GetAllDocuments(final Context ctx,final String userID) {
        ChaincodeStub stub = ctx.getStub();

        List<Document> queryResults = new ArrayList<>();

        // To retrieve all assets from the ledger use getStateByRange with empty startKey & endKey.
        // Giving empty startKey & endKey is interpreted as all the keys from beginning to end.
        // As another example, if you use startKey = 'asset0', endKey = 'asset9' ,
        // then getStateByRange will retrieve asset with keys between asset0 (inclusive) and asset9 (exclusive) in lexical order.
        QueryResultsIterator<KeyValue> results = stub.getStateByRange("", "");

        for (KeyValue result: results) {
            Document document = genson.deserialize(result.getStringValue(), Document.class);
            queryResults.add(document);

            //update who has read it and that it has been read 
            document.setLastAction(DocumentAction.READ);
            document.setLastInteractedWithID(userID);
            String sortedJson = genson.serialize(document);
            stub.putStringState(document.getDocumentID(), sortedJson);
            
        }

        final String response = genson.serialize(queryResults);

        return response;
    }

    

    /**
     * Retrieves all documents within a specified range from the ledger.
     *
     * @param ctx the transaction context
     * @param startKey the start key for the range (inclusive)
     * @param endKey the end key for the range (exclusive)
     * @param userID
     * @return JSON array of documents found within the range
     */
    @Transaction(intent = Transaction.TYPE.SUBMIT)
    public String GetAllDocumentsInRange(final Context ctx, final String startKey, final String endKey,final String userID) {
        ChaincodeStub stub = ctx.getStub();

        if (startKey.equals(endKey)) {
            String errorMessage = String.format("Entered two of the same key");
            System.out.println(errorMessage);
            throw new ChaincodeException(errorMessage, DocumentTransferErrors.DOCUMENT_NOT_FOUND.toString());
        }

        List<Document> queryResults = new ArrayList<>();

        // Use getStateByRange with startKey and endKey
        // This will retrieve all documents with keys between startKey (inclusive) and endKey (exclusive)
        QueryResultsIterator<KeyValue> results = stub.getStateByRange(startKey, endKey);

        // Iterate through the results and deserialize each document
        for (KeyValue result : results) {
            Document document = genson.deserialize(result.getStringValue(), Document.class);

            queryResults.add(document);

            //update who has read it and that it has been read 
            document.setLastAction(DocumentAction.READ);
            document.setLastInteractedWithID(userID);
            String sortedJson = genson.serialize(document);
            stub.putStringState(document.getDocumentID(), sortedJson);
            


        }

        // Serialize the list of documents to JSON and return
        return genson.serialize(queryResults);
    }

    /**
     * Retrieve the history of a given Key 
     * @param ctx context
     * @param documentID id of the documents history to fetch 
     * @return
     */
    @Transaction(intent = Transaction.TYPE.EVALUATE)
    public Document[] retrieveHistory(final Context ctx,final String documentID)  {
        ChaincodeStub stub = ctx.getStub();

        if (!CheckDocumentExists(ctx, documentID)) {
            String errorMessage = String.format("Document %s does not exist", documentID);
            System.out.println(errorMessage);
            throw new ChaincodeException(errorMessage, DocumentTransferErrors.DOCUMENT_NOT_FOUND.toString());
        }

        QueryResultsIterator<KeyModification> history = stub.getHistoryForKey(documentID);
        ArrayList<Document> historyList= new ArrayList<>();
        for(KeyModification k : history){

            Document doc = genson.deserialize(k.getStringValue(), Document.class);
            historyList.add(doc);
        }

        //cast to a document Array 
        return  historyList.toArray(new Document[0]);
    }

    /**
     * Check for duplicate hashes or names on ledger 
     * @param ctx
     * @param documentName
     * @param documentHash
     * @return boolean true if no duplicates and false if there are duplicates 
     */
    @Transaction(intent=Transaction.TYPE.EVALUATE)
    public boolean checkDuplicate(final Context ctx,final String documentName, final String documentHash){
        ChaincodeStub stub = ctx.getStub();

        if(documentName == null|| documentHash == null) {
            String errorMessage = String.format("INVALID ARGUMENTS");
            System.out.println(errorMessage);
            throw new ChaincodeException(errorMessage,"CANNOT CHECK DUPLICATES AS NAME OR HASH ARE NULL");
        }
        //get all items on ledger 
        QueryResultsIterator<KeyValue> results = stub.getStateByRange("", "");

        for (KeyValue result: results) {
            Document document = genson.deserialize(result.getStringValue(), Document.class);
            
            // Check if either the document name or the document hash already exists
            if ((documentName.equals(document.getDocumentName())) || 
                (documentHash.equals(document.getDocumentHash()))) {
                return false;  // Duplicate found
            }

   
        }

        return true;

    }
    


}